## draft procedures and functions

## Household price mutation
Procedure AgentH.PriceMutate(N : Integer);
const
  delta = 0.95;
var
  I : Integer;
begin
  for I := 1 to NumGoods do begin
    P[I] := AgentsH[Produces,N].P[I];
    if not CheckEfficiency and (Random < MRate) then begin
      if Random < 0.5 then P[I] := P[I]*Delta
      else P[I] := P[I]/Delta;
      if Random < 0.5 then S := S*Delta
      else S := S/Delta; 
    end;
  end;
end;

##Firm price mutation
Procedure AgentF.PriceMutate(N : Integer);
const
  delta = 0.95;
var
  I : Integer;
begin
  for I := 1 to NumGoods do begin
    Q[I] := AgentsH[Produces,N].Q[I];
    if not CheckEfficiency and (Random < MRate) then begin
      if Random < 0.5 then Q[I] := Q[I]*Delta
      else Q[I] := Q[I]/Delta;
      if Random < 0.5 then T := T*Delta
      else T := T/Delta;
    end;
  end;
end;

Procedure GetNextGenerationH1(G : Integer);
var
	I,J,K,Replacements : Integer;
begin
	Replacements := Round(NumAgentsH[G]*ReplacementRate);
  if Replacements = 0 then Inc(Replacements);
  for I := 1 to Replacements do begin
    Application.ProcessMessages;
    if HaltSimulation then Exit;
    J := 1 + Random(NumAgentsH[G]);
    K := 1 + Random(NumAgentsH[G]);
    if AgentsH[G,J].Score > AgentsH[G,K].Score then
      AgentsH[G,K].CopyAndMutate(J)
    else AgentsH[G,J].CopyAndMutate(K);
  end;
  for I := 1 to NumAgentsH[G] do AgentsH[G,I].Score := 0;
end;


Procedure GetNextGenerationF1(G : Integer);
var
	I,J,K,Replacements : Integer;
begin
	Replacements := Round(NumAgentsF[G]*ReplacementRate);
  if Replacements = 0 then Inc(Replacements);
  for I := 1 to Replacements do begin
    Application.ProcessMessages;
    if HaltSimulation then Exit;
    J := 1 + Random(NumAgentsF[G]);
    K := 1 + Random(NumAgentsF[G]);
    if AgentsF[G,J].Score > AgentsF[G,K].Score then
      AgentsF[G,K].CopyAndMutate(J)
    else AgentsF[G,J].CopyAndMutate(K);
  end;
  for I := 1 to NumAgentsF[G] do AgentsF[G,I].Score := 0;
end;

